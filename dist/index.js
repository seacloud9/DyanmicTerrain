/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var BABYLON;\n(function (BABYLON) {\n    var DynamicTerrain = (function () {\n        function DynamicTerrain(name, options, scene) {\n            var _this = this;\n            this._particleDataStride = 9;\n            this._particleColorStride = 4;\n            this._particleUVStride = 4;\n            this._subToleranceX = 1 | 0;\n            this._subToleranceZ = 1 | 0;\n            this._LODLimits = [];\n            this._initialLOD = 1 | 0;\n            this._LODValue = 1 | 0;\n            this._cameraLODCorrection = 0 | 0;\n            this._LODPositiveX = true;\n            this._LODNegativeX = true;\n            this._LODPositiveZ = true;\n            this._LODNegativeZ = true;\n            this._inverted = false;\n            this.shiftFromCamera = {\n                x: 0.0,\n                z: 0.0\n            };\n            this._deltaSubX = 0 | 0;\n            this._deltaSubZ = 0 | 0;\n            this._refreshEveryFrame = false;\n            this._useCustomVertexFunction = false;\n            this._computeNormals = false;\n            this._datamap = false;\n            this._uvmap = false;\n            this._colormap = false;\n            this._mapSPData = false;\n            this._colorSPData = false;\n            this._uvSPData = false;\n            this._averageSubSizeX = 0.0;\n            this._averageSubSizeZ = 0.0;\n            this._terrainSizeX = 0.0;\n            this._terrainSizeZ = 0.0;\n            this._terrainHalfSizeX = 0.0;\n            this._terrainHalfSizeZ = 0.0;\n            this._centerWorld = BABYLON.Vector3.Zero();\n            this._centerLocal = BABYLON.Vector3.Zero();\n            this._mapSizeX = 0.0;\n            this._mapSizeZ = 0.0;\n            this._isAlwaysVisible = false;\n            this._precomputeNormalsFromMap = false;\n            this.name = name;\n            this._terrainSub = options.terrainSub || 60;\n            this._mapData = options.mapData;\n            this._terrainIdx = this._terrainSub + 1;\n            this._mapSubX = options.mapSubX || this._terrainIdx;\n            this._mapSubZ = options.mapSubZ || this._terrainIdx;\n            this._mapUVs = options.mapUVs;\n            this._mapColors = options.mapColors;\n            this._scene = scene;\n            this._terrainCamera = options.camera || scene.activeCamera;\n            this._inverted = options.invertSide;\n            this._SPmapData = options.SPmapData;\n            this._SPcolorData = options.SPcolorData;\n            this._SPuvData = options.SPuvData;\n            this._sps = options.sps;\n            this._datamap = (this._mapData) ? true : false;\n            this._uvmap = (this._mapUVs) ? true : false;\n            this._colormap = (this._mapColors) ? true : false;\n            this._mapSPData = (this._SPmapData) ? true : false;\n            this._colorSPData = (this._mapSPData && this._SPcolorData) ? true : false;\n            this._uvSPData = (this._mapSPData && this._SPuvData) ? true : false;\n            this._mapData = (this._datamap) ? this._mapData : new Float32Array(this._terrainIdx * this._terrainIdx * 3);\n            this._mapUVs = (this._uvmap) ? this._mapUVs : new Float32Array(this._terrainIdx * this._terrainIdx * 2);\n            if (this._datamap) {\n                this._mapNormals = options.mapNormals || new Float32Array(this._mapSubX * this._mapSubZ * 3);\n            }\n            else {\n                this._mapNormals = new Float32Array(this._terrainIdx * this._terrainIdx * 3);\n            }\n            var index = 0;\n            var posIndex = 0;\n            var colIndex = 0;\n            var uvIndex = 0;\n            var color;\n            var uv;\n            var terIndex = 0;\n            var y = 0.0;\n            var terrainPath;\n            var u = 0.0;\n            var v = 0.0;\n            var lg = this._terrainIdx + 1;\n            var terrainData = [];\n            var terrainColor = [];\n            var terrainUV = [];\n            var mapData = this._mapData;\n            var mapColors = this._mapColors;\n            var mapUVs = this._mapUVs;\n            for (var j = 0; j <= this._terrainSub; j++) {\n                terrainPath = [];\n                for (var i = 0; i <= this._terrainSub; i++) {\n                    index = this._mod(j * 3, this._mapSubZ) * this._mapSubX + this._mod(i * 3, this._mapSubX);\n                    posIndex = index * 3;\n                    colIndex = index * 3;\n                    uvIndex = index * 2;\n                    terIndex = j * this._terrainIdx + i;\n                    if (this._datamap) {\n                        y = mapData[posIndex + 1];\n                    }\n                    else {\n                        y = 0.0;\n                        mapData[3 * terIndex] = i;\n                        mapData[3 * terIndex + 1] = y;\n                        mapData[3 * terIndex + 2] = j;\n                    }\n                    terrainPath.push(new BABYLON.Vector3(i, y, j));\n                    if (this._colormap) {\n                        color = new BABYLON.Color4(mapColors[colIndex], mapColors[colIndex + 1], mapColors[colIndex + 2], 1.0);\n                    }\n                    else {\n                        color = new BABYLON.Color4(1.0, 1.0, 1.0, 1.0);\n                    }\n                    terrainColor.push(color);\n                    if (this._uvmap) {\n                        uv = new BABYLON.Vector2(mapUVs[uvIndex], mapUVs[uvIndex + 1]);\n                    }\n                    else {\n                        u = 1.0 - Math.abs(1.0 - 2.0 * i / lg);\n                        v = 1.0 - Math.abs(1.0 - 2.0 * j / lg);\n                        mapUVs[2 * terIndex] = u;\n                        mapUVs[2 * terIndex + 1] = v;\n                        uv = new BABYLON.Vector2(u, v);\n                    }\n                    terrainUV.push(uv);\n                }\n                terrainData.push(terrainPath);\n            }\n            this._mapSizeX = Math.abs(mapData[(this._mapSubX - 1) * 3] - mapData[0]);\n            this._mapSizeZ = Math.abs(mapData[(this._mapSubZ - 1) * this._mapSubX * 3 + 2] - mapData[2]);\n            this._averageSubSizeX = this._mapSizeX / this._mapSubX;\n            this._averageSubSizeZ = this._mapSizeZ / this._mapSubZ;\n            var ribbonOptions = {\n                pathArray: terrainData,\n                sideOrientation: (options.invertSide) ? BABYLON.Mesh.FRONTSIDE : BABYLON.Mesh.BACKSIDE,\n                colors: terrainColor,\n                uvs: terrainUV,\n                updatable: true\n            };\n            this._terrain = BABYLON.MeshBuilder.CreateRibbon(\"terrain\", ribbonOptions, this._scene);\n            this._indices = this._terrain.getIndices();\n            this._positions = this._terrain.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            this._normals = this._terrain.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            this._uvs = this._terrain.getVerticesData(BABYLON.VertexBuffer.UVKind);\n            this._colors = this._terrain.getVerticesData(BABYLON.VertexBuffer.ColorKind);\n            this.computeNormalsFromMap();\n            this.update(true);\n            this._terrain.position.x = this._terrainCamera.globalPosition.x - this._terrainHalfSizeX + this.shiftFromCamera.x;\n            this._terrain.position.z = this._terrainCamera.globalPosition.z - this._terrainHalfSizeZ + this.shiftFromCamera.z;\n            var deltaNbSubX = (this._terrain.position.x - mapData[0]) / this._averageSubSizeX;\n            var deltaNbSubZ = (this._terrain.position.z - mapData[2]) / this._averageSubSizeZ;\n            this._deltaSubX = (deltaNbSubX > 0) ? Math.floor(deltaNbSubX) : Math.ceil(deltaNbSubX);\n            this._deltaSubZ = (deltaNbSubZ > 0) ? Math.floor(deltaNbSubZ) : Math.ceil(deltaNbSubZ);\n            this._scene.onBeforeRenderObservable.add(function () {\n                var refreshEveryFrame = _this._refreshEveryFrame;\n                _this.beforeUpdate(refreshEveryFrame);\n                _this.update(refreshEveryFrame);\n                _this.afterUpdate(refreshEveryFrame);\n            });\n            var SPmapData = this._SPmapData;\n            var dataStride = this._particleDataStride;\n            if (this._mapSPData) {\n                var mapSizeX = this._mapSizeX;\n                var mapSizeZ = this._mapSizeZ;\n                var mapSubX = this._mapSubX;\n                var mapSubZ = this._mapSubZ;\n                var quads = [];\n                this._mapQuads = quads;\n                var x0 = mapData[0];\n                var z0 = mapData[2];\n                for (var t = 0; t < SPmapData.length; t++) {\n                    var data = SPmapData[t];\n                    var nb = (data.length / dataStride) | 0;\n                    for (var pIdx = 0; pIdx < nb; pIdx++) {\n                        var dIdx = pIdx * dataStride;\n                        var x = data[dIdx];\n                        var z = data[dIdx + 2];\n                        x = x - Math.floor((x - x0) / mapSizeX) * mapSizeX;\n                        z = z - Math.floor((z - z0) / mapSizeZ) * mapSizeZ;\n                        var col = Math.floor((x - x0) * mapSubX / mapSizeX);\n                        var row = Math.floor((z - z0) * mapSubZ / mapSizeZ);\n                        var quadIdx = row * mapSubX + col;\n                        if (quads[quadIdx] === undefined) {\n                            quads[quadIdx] = [];\n                        }\n                        if (quads[quadIdx][t] === undefined) {\n                            quads[quadIdx][t] = [];\n                        }\n                        var quad = quads[quadIdx][t];\n                        quad.push(pIdx);\n                    }\n                }\n                var sps = this._sps;\n                sps.computeBoundingBox = true;\n                sps.isAlwaysVisible = true;\n                if (this._colorSPData) {\n                    sps.computeParticleColor = true;\n                }\n                if (this._uvSPData) {\n                    sps.computeParticleTexture = true;\n                }\n                var spsTypeStartIndexes = [];\n                this._spsTypeStartIndexes = spsTypeStartIndexes;\n                var spsNbPerType = [];\n                this._spsNbPerType = spsNbPerType;\n                var nbAvailablePerType = [];\n                this._nbAvailablePerType = nbAvailablePerType;\n                var nbParticles = sps.nbParticles;\n                var particles = sps.particles;\n                var type = 0;\n                spsTypeStartIndexes.push(type);\n                nbAvailablePerType.push(0);\n                var count = 1;\n                for (var p = 1; p < nbParticles; p++) {\n                    particles[p].isVisible = false;\n                    if (type != particles[p].shapeId) {\n                        type++;\n                        spsTypeStartIndexes.push(p);\n                        spsNbPerType.push(count);\n                        nbAvailablePerType.push(count);\n                        count = 0;\n                    }\n                    count++;\n                }\n                spsNbPerType.push(count);\n            }\n            this.update(true);\n        }\n        DynamicTerrain.prototype.update = function (force) {\n            var needsUpdate = false;\n            var updateLOD = false;\n            var updateForced = (force) ? true : false;\n            var terrainPosition = this._terrain.position;\n            var cameraPosition = this._terrainCamera.globalPosition;\n            var shiftFromCamera = this.shiftFromCamera;\n            var terrainHalfSizeX = this._terrainHalfSizeX;\n            var terrainHalfSizeZ = this._terrainHalfSizeZ;\n            var deltaX = terrainHalfSizeX + terrainPosition.x - cameraPosition.x - shiftFromCamera.x;\n            var deltaZ = terrainHalfSizeZ + terrainPosition.z - cameraPosition.z - shiftFromCamera.z;\n            var subToleranceX = this._subToleranceX;\n            var subToleranceZ = this._subToleranceZ;\n            var mod = this._mod;\n            var oldCorrection = this._cameraLODCorrection;\n            this._cameraLODCorrection = (this.updateCameraLOD(this._terrainCamera)) | 0;\n            updateLOD = (oldCorrection == this._cameraLODCorrection) ? false : true;\n            var LODValue = this._initialLOD + this._cameraLODCorrection;\n            LODValue = (LODValue > 0) ? LODValue : 1;\n            this._LODValue = LODValue;\n            var mapShiftX = this._averageSubSizeX * subToleranceX * LODValue;\n            var mapShiftZ = this._averageSubSizeZ * subToleranceZ * LODValue;\n            var mapFlgtNb = 0 | 0;\n            var deltaSubX = this._deltaSubX;\n            var deltaSubZ = this._deltaSubZ;\n            if (Math.abs(deltaX) > mapShiftX) {\n                var signX = (deltaX > 0.0) ? -1 : 1;\n                mapFlgtNb = Math.abs(deltaX / mapShiftX) | 0;\n                terrainPosition.x += mapShiftX * signX * mapFlgtNb;\n                deltaSubX += (subToleranceX * signX * LODValue * mapFlgtNb);\n                needsUpdate = true;\n            }\n            if (Math.abs(deltaZ) > mapShiftZ) {\n                var signZ = (deltaZ > 0.0) ? -1 : 1;\n                mapFlgtNb = Math.abs(deltaZ / mapShiftZ) | 0;\n                terrainPosition.z += mapShiftZ * signZ * mapFlgtNb;\n                deltaSubZ += (subToleranceZ * signZ * LODValue * mapFlgtNb);\n                needsUpdate = true;\n            }\n            var updateSize = updateLOD || updateForced;\n            if (needsUpdate || updateSize) {\n                this._deltaSubX = mod(deltaSubX, this._mapSubX);\n                this._deltaSubZ = mod(deltaSubZ, this._mapSubZ);\n                this._updateTerrain(updateSize);\n            }\n            terrainHalfSizeX = this._terrainHalfSizeX;\n            terrainHalfSizeZ = this._terrainHalfSizeZ;\n            this.centerLocal.copyFromFloats(terrainHalfSizeX, 0.0, terrainHalfSizeZ);\n            this._centerWorld.copyFromFloats(terrainPosition.x + terrainHalfSizeX, terrainPosition.y, terrainPosition.z + terrainHalfSizeZ);\n            return this;\n        };\n        DynamicTerrain.prototype._updateTerrain = function (updateSize) {\n            var stepJ = 0 | 0;\n            var stepI = 0 | 0;\n            var LODLimitDown = 0 | 0;\n            var LODLimitUp = 0 | 0;\n            var LODValue = this._LODValue;\n            var axisLODValue = LODValue;\n            var lodI = LODValue;\n            var lodJ = LODValue;\n            var bbMin = DynamicTerrain._bbMin;\n            var bbMax = DynamicTerrain._bbMax;\n            var terrain = this._terrain;\n            var positions = this._positions;\n            var normals = this._normals;\n            var colors = this._colors;\n            var uvs = this._uvs;\n            var mapColors = this._mapColors;\n            var mapNormals = this._mapNormals;\n            var mapData = this._mapData;\n            var mapUVs = this._mapUVs;\n            var mapSPData = this._mapSPData;\n            var quads = this._mapQuads;\n            var nbPerType = this._spsNbPerType;\n            var SPmapData = this._SPmapData;\n            var SPcolorData = this._SPcolorData;\n            var SPuvData = this._SPuvData;\n            var dataStride = this._particleDataStride;\n            var colorStride = this._particleColorStride;\n            var uvStride = this._particleUVStride;\n            var LODLimits = this._LODLimits;\n            var terrainSub = this._terrainSub;\n            var mod = this._mod;\n            var terrainIdx = this._terrainIdx;\n            var mapSubX = this._mapSubX;\n            var mapSubZ = this._mapSubZ;\n            var deltaSubX = this._deltaSubX;\n            var deltaSubZ = this._deltaSubZ;\n            var datamap = this._datamap;\n            var uvmap = this._uvmap;\n            var colormap = this._colormap;\n            var useCustomVertexFunction = this._useCustomVertexFunction;\n            var updateVertex = this.updateVertex;\n            var dontComputeNormals = !this._computeNormals;\n            var LODpstvX = this._LODPositiveX;\n            var LODngtvX = this._LODNegativeX;\n            var LODpstvZ = this._LODPositiveZ;\n            var LODngtvZ = this._LODNegativeZ;\n            var mapSizeX = this._mapSizeX;\n            var mapSizeZ = this._mapSizeZ;\n            var averageSubSizeX = this._averageSubSizeX;\n            var averageSubSizeZ = this._averageSubSizeZ;\n            var particleMap = (mapSPData && quads);\n            var particleColorMap = (particleMap && this._colorSPData);\n            var particleUVMap = (particleMap && this._uvSPData);\n            var l = 0 | 0;\n            var index = 0 | 0;\n            var posIndex1 = 0 | 0;\n            var posIndex2 = 0 | 0;\n            var posIndex3 = 0 | 0;\n            var colIndex = 0 | 0;\n            var uvIndex = 0 | 0;\n            var terIndex = 0 | 0;\n            var ribbonInd = 0 | 0;\n            var ribbonPosInd = 0 | 0;\n            var ribbonUVInd = 0 | 0;\n            var ribbonColInd = 0 | 0;\n            var ribbonColInd1 = 0 | 0;\n            var ribbonColInd2 = 0 | 0;\n            var ribbonColInd3 = 0 | 0;\n            var ribbonColInd4 = 0 | 0;\n            var ribbonPosInd1 = 0 | 0;\n            var ribbonPosInd2 = 0 | 0;\n            var ribbonPosInd3 = 0 | 0;\n            if (updateSize) {\n                this.updateTerrainSize();\n            }\n            BABYLON.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, bbMin);\n            BABYLON.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, bbMax);\n            if (particleMap) {\n                var sps = this._sps;\n                var particles = sps.particles;\n                var spsTypeStartIndexes = this._spsTypeStartIndexes;\n                var nbAvailablePerType = this._nbAvailablePerType;\n                var x0 = mapData[0];\n                var z0 = mapData[2];\n                var terrainPos = terrain.position;\n                var nbParticles = sps.nbParticles;\n                for (var p = 0; p < nbParticles; p++) {\n                    particles[p].isVisible = false;\n                }\n            }\n            for (var j = 0 | 0; j <= terrainSub; j++) {\n                axisLODValue = LODValue;\n                for (l = 0; l < LODLimits.length; l++) {\n                    LODLimitDown = LODLimits[l];\n                    LODLimitUp = terrainSub - LODLimitDown - 1;\n                    if ((LODngtvZ && j < LODLimitDown) || (LODpstvZ && j > LODLimitUp)) {\n                        axisLODValue = l + 1 + LODValue;\n                    }\n                    lodJ = axisLODValue;\n                }\n                for (var i = 0 | 0; i <= terrainSub; i++) {\n                    axisLODValue = LODValue;\n                    for (l = 0; l < LODLimits.length; l++) {\n                        LODLimitDown = LODLimits[l];\n                        LODLimitUp = terrainSub - LODLimitDown - 1;\n                        if ((LODngtvX && i < LODLimitDown) || (LODpstvX && i > LODLimitUp)) {\n                            axisLODValue = l + 1 + LODValue;\n                        }\n                        lodI = axisLODValue;\n                    }\n                    index = mod(deltaSubZ + stepJ, mapSubZ) * mapSubX + mod(deltaSubX + stepI, mapSubX);\n                    terIndex = mod(deltaSubZ + stepJ, terrainIdx) * terrainIdx + mod(deltaSubX + stepI, terrainIdx);\n                    if (datamap) {\n                        posIndex1 = 3 * index;\n                    }\n                    else {\n                        posIndex1 = 3 * terIndex;\n                    }\n                    if (uvmap) {\n                        uvIndex = 2 * index;\n                    }\n                    else {\n                        uvIndex = 2 * terIndex;\n                    }\n                    if (colormap) {\n                        colIndex = 3 * index;\n                    }\n                    else {\n                        colIndex = 3 * terIndex;\n                    }\n                    posIndex2 = posIndex1 + 1;\n                    posIndex3 = posIndex1 + 2;\n                    ribbonPosInd = 3 * ribbonInd;\n                    ribbonColInd = 4 * ribbonInd;\n                    ribbonUVInd = 2 * ribbonInd;\n                    ribbonPosInd1 = ribbonPosInd;\n                    ribbonPosInd2 = ribbonPosInd + 1;\n                    ribbonPosInd3 = ribbonPosInd + 2;\n                    ribbonColInd1 = ribbonColInd;\n                    ribbonColInd2 = ribbonColInd + 1;\n                    ribbonColInd3 = ribbonColInd + 2;\n                    ribbonColInd4 = ribbonColInd + 3;\n                    ribbonInd += 1;\n                    positions[ribbonPosInd1] = averageSubSizeX * stepI;\n                    positions[ribbonPosInd2] = mapData[posIndex2];\n                    positions[ribbonPosInd3] = averageSubSizeZ * stepJ;\n                    if (dontComputeNormals) {\n                        normals[ribbonPosInd1] = mapNormals[posIndex1];\n                        normals[ribbonPosInd2] = mapNormals[posIndex2];\n                        normals[ribbonPosInd3] = mapNormals[posIndex3];\n                    }\n                    if (positions[ribbonPosInd1] < bbMin.x) {\n                        bbMin.x = positions[ribbonPosInd1];\n                    }\n                    if (positions[ribbonPosInd1] > bbMax.x) {\n                        bbMax.x = positions[ribbonPosInd1];\n                    }\n                    if (positions[ribbonPosInd2] < bbMin.y) {\n                        bbMin.y = positions[ribbonPosInd2];\n                    }\n                    if (positions[ribbonPosInd2] > bbMax.y) {\n                        bbMax.y = positions[ribbonPosInd2];\n                    }\n                    if (positions[ribbonPosInd3] < bbMin.z) {\n                        bbMin.z = positions[ribbonPosInd3];\n                    }\n                    if (positions[ribbonPosInd3] > bbMax.z) {\n                        bbMax.z = positions[ribbonPosInd3];\n                    }\n                    if (colormap) {\n                        colors[ribbonColInd1] = mapColors[colIndex];\n                        colors[ribbonColInd2] = mapColors[colIndex + 1];\n                        colors[ribbonColInd3] = mapColors[colIndex + 2];\n                    }\n                    uvs[ribbonUVInd] = mapUVs[uvIndex];\n                    uvs[ribbonUVInd + 1] = mapUVs[uvIndex + 1];\n                    if (useCustomVertexFunction) {\n                        var vertex = DynamicTerrain._vertex;\n                        var vertexPosition = vertex.position;\n                        var vertexWorldPosition = vertex.worldPosition;\n                        var vertexColor = vertex.color;\n                        var vertexUvs = vertex.uvs;\n                        vertexPosition.copyFromFloats(positions[ribbonPosInd1], positions[ribbonPosInd2], positions[ribbonPosInd3]);\n                        vertexWorldPosition.copyFromFloats(mapData[posIndex1], vertexPosition.y, mapData[posIndex3]);\n                        vertex.lodX = lodI;\n                        vertex.lodZ = lodJ;\n                        vertexColor.copyFromFloats(colors[ribbonColInd1], colors[ribbonColInd2], colors[ribbonColInd3], colors[ribbonColInd4]);\n                        vertexUvs.copyFromFloats(uvs[ribbonUVInd], uvs[ribbonUVInd + 1]);\n                        vertex.mapIndex = index;\n                        updateVertex(vertex, i, j);\n                        colors[ribbonColInd1] = vertexColor.r;\n                        colors[ribbonColInd2] = vertexColor.g;\n                        colors[ribbonColInd3] = vertexColor.b;\n                        colors[ribbonColInd4] = vertexColor.a;\n                        uvs[ribbonUVInd] = vertexUvs.x;\n                        uvs[ribbonUVInd + 1] = vertexUvs.y;\n                        positions[ribbonPosInd1] = vertexPosition.x;\n                        positions[ribbonPosInd2] = vertexPosition.y;\n                        positions[ribbonPosInd3] = vertexPosition.z;\n                    }\n                    if (particleMap) {\n                        var quad = quads[index];\n                        if (quad) {\n                            for (var t = 0; t < quad.length; t++) {\n                                var data = SPmapData[t];\n                                var partIndexes = quad[t];\n                                if (particleColorMap) {\n                                    var sp_colorData = SPcolorData[t];\n                                }\n                                if (particleUVMap) {\n                                    var sp_uvData = SPuvData[t];\n                                }\n                                if (partIndexes) {\n                                    var typeStartIndex = spsTypeStartIndexes[t];\n                                    var nbQuadParticles = partIndexes.length;\n                                    var nbInSPS = nbPerType[t];\n                                    var available = nbAvailablePerType[t];\n                                    var rem = nbInSPS - available;\n                                    var used = (rem > 0) ? rem : 0;\n                                    var min = (available < nbQuadParticles) ? available : nbQuadParticles;\n                                    for (var pIdx = 0; pIdx < min; pIdx++) {\n                                        var px = partIndexes[pIdx];\n                                        var idm = px * dataStride;\n                                        var particle = particles[typeStartIndex + pIdx + used];\n                                        var pos = particle.position;\n                                        var rot = particle.rotation;\n                                        var scl = particle.scaling;\n                                        var x = data[idm];\n                                        pos.x = x + Math.floor((terrainPos.x - x - x0) / mapSizeX) * mapSizeX;\n                                        pos.y = data[idm + 1];\n                                        var z = data[idm + 2];\n                                        pos.z = z + Math.floor((terrainPos.z - z - z0) / mapSizeZ) * mapSizeZ;\n                                        rot.x = data[idm + 3];\n                                        rot.y = data[idm + 4];\n                                        rot.z = data[idm + 5];\n                                        scl.x = data[idm + 6];\n                                        scl.y = data[idm + 7];\n                                        scl.z = data[idm + 8];\n                                        if (particleColorMap) {\n                                            var idc = px * colorStride;\n                                            var col = particle.color;\n                                            col.r = sp_colorData[idc];\n                                            col.g = sp_colorData[idc + 1];\n                                            col.b = sp_colorData[idc + 2];\n                                            col.a = sp_colorData[idc + 3];\n                                        }\n                                        if (particleUVMap) {\n                                            var iduv = px * uvStride;\n                                            var uvs_1 = particle.uvs;\n                                            uvs_1.x = sp_uvData[iduv];\n                                            uvs_1.y = sp_uvData[iduv + 1];\n                                            uvs_1.z = sp_uvData[iduv + 2];\n                                            uvs_1.w = sp_uvData[iduv + 3];\n                                        }\n                                        particle.isVisible = true;\n                                        available = available - 1;\n                                        used = used + 1;\n                                        min = (available < nbQuadParticles) ? available : nbQuadParticles;\n                                    }\n                                    available = (available > 0) ? available : 0;\n                                    nbAvailablePerType[t] = available;\n                                }\n                            }\n                        }\n                    }\n                    stepI += lodI;\n                }\n                stepI = 0;\n                stepJ += lodJ;\n            }\n            if (particleMap) {\n                sps.setParticles();\n                for (var c = 0; c < nbAvailablePerType.length; c++) {\n                    nbAvailablePerType[c] = nbPerType[c];\n                }\n            }\n            terrain.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions, false, false);\n            if (this._computeNormals) {\n                BABYLON.VertexData.ComputeNormals(positions, this._indices, normals);\n            }\n            terrain.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals, false, false);\n            terrain.updateVerticesData(BABYLON.VertexBuffer.UVKind, uvs, false, false);\n            terrain.updateVerticesData(BABYLON.VertexBuffer.ColorKind, colors, false, false);\n            terrain._boundingInfo.reConstruct(bbMin, bbMax, terrain._worldMatrix);\n        };\n        ;\n        DynamicTerrain.prototype._mod = function (a, b) {\n            return ((a % b) + b) % b;\n        };\n        DynamicTerrain.prototype.updateTerrainSize = function () {\n            var remainder = this._terrainSub;\n            var nb = 0 | 0;\n            var next = 0 | 0;\n            var LODValue = this._LODValue;\n            var lod = LODValue + 1;\n            var tsx = 0.0;\n            var tsz = 0.0;\n            var LODLimits = this._LODLimits;\n            var averageSubSizeX = this._averageSubSizeX;\n            var averageSubSizeZ = this._averageSubSizeZ;\n            for (var l = 0 | 0; l < LODLimits.length; l++) {\n                lod = LODValue + l + 1;\n                next = (l >= LODLimits.length - 1) ? 0 : LODLimits[l + 1];\n                nb = 2 * (LODLimits[l] - next);\n                tsx += averageSubSizeX * lod * nb;\n                tsz += averageSubSizeZ * lod * nb;\n                remainder -= nb;\n            }\n            tsx += remainder * averageSubSizeX * LODValue;\n            tsz += remainder * averageSubSizeZ * LODValue;\n            this._terrainSizeX = tsx;\n            this._terrainSizeZ = tsz;\n            this._terrainHalfSizeX = tsx * 0.5;\n            this._terrainHalfSizeZ = tsz * 0.5;\n            return this;\n        };\n        DynamicTerrain.prototype.getHeightFromMap = function (x, z, options) {\n            return DynamicTerrain._GetHeightFromMap(x, z, this._mapData, this._mapSubX, this._mapSubZ, this._mapSizeX, this._mapSizeZ, options, this._inverted);\n        };\n        DynamicTerrain.GetHeightFromMap = function (x, z, mapData, mapSubX, mapSubZ, options, inverted) {\n            var mapSizeX = Math.abs(mapData[(mapSubX - 1) * 3] - mapData[0]);\n            var mapSizeZ = Math.abs(mapData[(mapSubZ - 1) * mapSubX * 3 + 2] - mapData[2]);\n            return DynamicTerrain._GetHeightFromMap(x, z, mapData, mapSubX, mapSubZ, mapSizeX, mapSizeZ, options, inverted);\n        };\n        DynamicTerrain._GetHeightFromMap = function (x, z, mapData, mapSubX, mapSubZ, mapSizeX, mapSizeZ, options, inverted) {\n            var x0 = mapData[0];\n            var z0 = mapData[2];\n            x = x - Math.floor((x - x0) / mapSizeX) * mapSizeX;\n            z = z - Math.floor((z - z0) / mapSizeZ) * mapSizeZ;\n            var col1 = Math.floor((x - x0) * mapSubX / mapSizeX);\n            var row1 = Math.floor((z - z0) * mapSubZ / mapSizeZ);\n            var col2 = (col1 + 1) % mapSubX;\n            var row2 = (row1 + 1) % mapSubZ;\n            var idx1 = 3 * (row1 * mapSubX + col1);\n            var idx2 = 3 * (row1 * mapSubX + col2);\n            var idx3 = 3 * ((row2) * mapSubX + col1);\n            var idx4 = 3 * ((row2) * mapSubX + col2);\n            var v1 = DynamicTerrain._v1;\n            var v2 = DynamicTerrain._v2;\n            var v3 = DynamicTerrain._v3;\n            var v4 = DynamicTerrain._v4;\n            v1.copyFromFloats(mapData[idx1], mapData[idx1 + 1], mapData[idx1 + 2]);\n            v2.copyFromFloats(mapData[idx2], mapData[idx2 + 1], mapData[idx2 + 2]);\n            v3.copyFromFloats(mapData[idx3], mapData[idx3 + 1], mapData[idx3 + 2]);\n            v4.copyFromFloats(mapData[idx4], mapData[idx4 + 1], mapData[idx4 + 2]);\n            var vAvB = DynamicTerrain._vAvB;\n            var vAvC = DynamicTerrain._vAvC;\n            var norm = DynamicTerrain._norm;\n            var vA = v1;\n            var vB;\n            var vC;\n            var v;\n            var xv4v1 = v4.x - v1.x;\n            var zv4v1 = v4.z - v1.z;\n            if (xv4v1 == 0 || zv4v1 == 0) {\n                return v1.y;\n            }\n            var cd = zv4v1 / xv4v1;\n            var h = v1.z - cd * v1.x;\n            if (z < cd * x + h) {\n                vB = v4;\n                vC = v2;\n                v = vA;\n            }\n            else {\n                vB = v3;\n                vC = v4;\n                v = vB;\n            }\n            vB.subtractToRef(vA, vAvB);\n            vC.subtractToRef(vA, vAvC);\n            BABYLON.Vector3.CrossToRef(vAvB, vAvC, norm);\n            norm.normalize();\n            if (inverted) {\n                norm.scaleInPlace(-1.0);\n            }\n            if (options && options.normal) {\n                options.normal.copyFrom(norm);\n            }\n            var d = -(norm.x * v.x + norm.y * v.y + norm.z * v.z);\n            var y = v.y;\n            if (norm.y != 0.0) {\n                y = -(norm.x * x + norm.z * z + d) / norm.y;\n            }\n            return y;\n        };\n        DynamicTerrain.ComputeNormalsFromMapToRef = function (mapData, mapSubX, mapSubZ, normals, inverted) {\n            var mapIndices = [];\n            var tmp1 = { normal: BABYLON.Vector3.Zero() };\n            var tmp2 = { normal: BABYLON.Vector3.Zero() };\n            var normal1 = tmp1.normal;\n            var normal2 = tmp2.normal;\n            var l = mapSubX * (mapSubZ - 1);\n            var i = 0;\n            for (i = 0; i < l; i++) {\n                mapIndices.push(i + 1, i + mapSubX, i);\n                mapIndices.push(i + mapSubX, i + 1, i + mapSubX + 1);\n            }\n            BABYLON.VertexData.ComputeNormals(mapData, mapIndices, normals);\n            var lastIdx = (mapSubX - 1) * 3;\n            var colStart = 0;\n            var colEnd = 0;\n            var getHeightFromMap = DynamicTerrain.GetHeightFromMap;\n            for (i = 0; i < mapSubZ; i++) {\n                colStart = i * mapSubX * 3;\n                colEnd = colStart + lastIdx;\n                getHeightFromMap(mapData[colStart], mapData[colStart + 2], mapData, mapSubX, mapSubZ, tmp1);\n                getHeightFromMap(mapData[colEnd], mapData[colEnd + 2], mapData, mapSubX, mapSubZ, tmp2);\n                normal1.addInPlace(normal2).scaleInPlace(0.5);\n                normals[colStart] = normal1.x;\n                normals[colStart + 1] = normal1.y;\n                normals[colStart + 2] = normal1.z;\n                normals[colEnd] = normal1.x;\n                normals[colEnd + 1] = normal1.y;\n                normals[colEnd + 2] = normal1.z;\n            }\n            if (inverted) {\n                for (i = 0; i < normals.length; i++) {\n                    normals[i] = -normals[i];\n                }\n            }\n        };\n        DynamicTerrain.prototype.computeNormalsFromMap = function () {\n            DynamicTerrain.ComputeNormalsFromMapToRef(this._mapData, this._mapSubX, this._mapSubZ, this._mapNormals, this._inverted);\n            return this;\n        };\n        DynamicTerrain.prototype.contains = function (x, z) {\n            var positions = this._positions;\n            var meshPosition = this.mesh.position;\n            var terrainIdx = this._terrainIdx;\n            if (x < positions[0] + meshPosition.x || x > positions[3 * terrainIdx] + meshPosition.x) {\n                return false;\n            }\n            if (z < positions[2] + meshPosition.z || z > positions[3 * terrainIdx * terrainIdx + 2] + meshPosition.z) {\n                return false;\n            }\n            return true;\n        };\n        DynamicTerrain.CreateMapFromHeightMap = function (heightmapURL, options, scene) {\n            var subX = options.subX || 100;\n            var subZ = options.subZ || 100;\n            var data = new Float32Array(subX * subZ * 3);\n            DynamicTerrain.CreateMapFromHeightMapToRef(heightmapURL, options, data, scene);\n            return data;\n        };\n        DynamicTerrain.CreateMapFromHeightMapToRef = function (heightmapURL, options, data, scene) {\n            var width = options.width || 300;\n            var height = options.height || 300;\n            var subX = options.subX || 100;\n            var subZ = options.subZ || 100;\n            var minHeight = options.minHeight || 0.0;\n            var maxHeight = options.maxHeight || 10.0;\n            var offsetX = options.offsetX || 0.0;\n            var offsetZ = options.offsetZ || 0.0;\n            var filter = options.colorFilter || new BABYLON.Color3(0.3, 0.59, 0.11);\n            var onReady = options.onReady;\n            var onload = function (img) {\n                var canvas = document.createElement(\"canvas\");\n                var context = canvas.getContext(\"2d\");\n                var bufferWidth = img.width;\n                var bufferHeight = img.height;\n                canvas.width = bufferWidth;\n                canvas.height = bufferHeight;\n                context.drawImage(img, 0, 0);\n                var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;\n                var x = 0.0;\n                var y = 0.0;\n                var z = 0.0;\n                for (var row = 0; row < subZ; row++) {\n                    for (var col = 0; col < subX; col++) {\n                        x = col * width / subX - width * 0.5;\n                        z = row * height / subZ - height * 0.5;\n                        var heightmapX = ((x + width * 0.5) / width * (bufferWidth - 1)) | 0;\n                        var heightmapY = (bufferHeight - 1) - ((z + height * 0.5) / height * (bufferHeight - 1)) | 0;\n                        var pos = (heightmapX + heightmapY * bufferWidth) * 4;\n                        var gradient = (buffer[pos] * filter.r + buffer[pos + 1] * filter.g + buffer[pos + 2] * filter.b) / 255.0;\n                        y = minHeight + (maxHeight - minHeight) * gradient;\n                        var idx = (row * subX + col) * 3;\n                        data[idx] = x + offsetX;\n                        data[idx + 1] = y;\n                        data[idx + 2] = z + offsetZ;\n                    }\n                }\n                if (onReady) {\n                    onReady(data, subX, subZ);\n                }\n            };\n            BABYLON.Tools.LoadImage(heightmapURL, onload, function () { }, scene.offlineProvider);\n        };\n        DynamicTerrain.CreateUVMapToRef = function (subX, subZ, mapUVs) {\n            for (var h = 0; h < subZ; h++) {\n                for (var w = 0; w < subX; w++) {\n                    mapUVs[(h * subX + w) * 2] = w / subX;\n                    mapUVs[(h * subX + w) * 2 + 1] = h / subZ;\n                }\n            }\n        };\n        DynamicTerrain.CreateUVMap = function (subX, subZ) {\n            var mapUVs = new Float32Array(subX * subZ * 2);\n            DynamicTerrain.CreateUVMapToRef(subX, subZ, mapUVs);\n            return mapUVs;\n        };\n        DynamicTerrain.prototype.createUVMap = function () {\n            this.mapUVs = DynamicTerrain.CreateUVMap(this._mapSubX, this._mapSubZ);\n            return this;\n        };\n        Object.defineProperty(DynamicTerrain.prototype, \"refreshEveryFrame\", {\n            get: function () {\n                return this._refreshEveryFrame;\n            },\n            set: function (val) {\n                this._refreshEveryFrame = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"mesh\", {\n            get: function () {\n                return this._terrain;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"camera\", {\n            get: function () {\n                return this._terrainCamera;\n            },\n            set: function (val) {\n                this._terrainCamera = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"subToleranceX\", {\n            get: function () {\n                return this._subToleranceX;\n            },\n            set: function (val) {\n                this._subToleranceX = (val > 0) ? val : 1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"subToleranceZ\", {\n            get: function () {\n                return this._subToleranceZ;\n            },\n            set: function (val) {\n                this._subToleranceZ = (val > 0) ? val : 1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"initialLOD\", {\n            get: function () {\n                return this._initialLOD;\n            },\n            set: function (val) {\n                this._initialLOD = (val > 0) ? val : 1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"LODValue\", {\n            get: function () {\n                return this._LODValue;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"cameraLODCorrection\", {\n            get: function () {\n                return this._cameraLODCorrection;\n            },\n            set: function (val) {\n                this._cameraLODCorrection = (val >= 0) ? val : 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"LODPositiveX\", {\n            get: function () {\n                return this._LODPositiveX;\n            },\n            set: function (val) {\n                this._LODPositiveX = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"LODNegativeX\", {\n            get: function () {\n                return this._LODNegativeX;\n            },\n            set: function (val) {\n                this._LODNegativeX = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"LODPositiveZ\", {\n            get: function () {\n                return this._LODPositiveZ;\n            },\n            set: function (val) {\n                this._LODPositiveZ = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"LODNegativeZ\", {\n            get: function () {\n                return this._LODNegativeZ;\n            },\n            set: function (val) {\n                this._LODNegativeZ = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"averageSubSizeX\", {\n            get: function () {\n                return this._averageSubSizeX;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"averageSubSizeZ\", {\n            get: function () {\n                return this._averageSubSizeZ;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"terrainSizeX\", {\n            get: function () {\n                return this._terrainSizeX;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"terrainHalfSizeX\", {\n            get: function () {\n                return this._terrainHalfSizeX;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"terrainSizeZ\", {\n            get: function () {\n                return this._terrainSizeZ;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"terrainHalfSizeZ\", {\n            get: function () {\n                return this._terrainHalfSizeZ;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"centerLocal\", {\n            get: function () {\n                return this._centerLocal;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"centerWorld\", {\n            get: function () {\n                return this._centerWorld;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"LODLimits\", {\n            get: function () {\n                return this._LODLimits;\n            },\n            set: function (ar) {\n                ar.sort(function (a, b) {\n                    return b - a;\n                });\n                this._LODLimits = ar;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"mapData\", {\n            get: function () {\n                return this._mapData;\n            },\n            set: function (val) {\n                this._mapData = val;\n                this._datamap = true;\n                var mapSubX = this._mapSubX;\n                var mapSubZ = this._mapSubZ;\n                this._mapSizeX = Math.abs(val[(mapSubX - 1) * 3] - val[0]);\n                this._mapSizeZ = Math.abs(val[(mapSubZ - 1) * mapSubX * 3 + 2] - val[2]);\n                this._averageSubSizeX = this._mapSizeX / mapSubX;\n                this._averageSubSizeZ = this._mapSizeZ / mapSubZ;\n                if (this._precomputeNormalsFromMap) {\n                    this.computeNormalsFromMap();\n                }\n                this.update(true);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"mapSubX\", {\n            get: function () {\n                return this._mapSubX;\n            },\n            set: function (val) {\n                this._mapSubX = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"mapSubZ\", {\n            get: function () {\n                return this._mapSubZ;\n            },\n            set: function (val) {\n                this._mapSubZ = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"mapColors\", {\n            get: function () {\n                return this._mapColors;\n            },\n            set: function (val) {\n                this._colormap = true;\n                this._mapColors = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"mapUVs\", {\n            get: function () {\n                return this._mapUVs;\n            },\n            set: function (val) {\n                this._uvmap = true;\n                this._mapUVs = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"mapNormals\", {\n            get: function () {\n                return this._mapNormals;\n            },\n            set: function (val) {\n                this._mapNormals = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"computeNormals\", {\n            get: function () {\n                return this._computeNormals;\n            },\n            set: function (val) {\n                this._computeNormals = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"useCustomVertexFunction\", {\n            get: function () {\n                return this._useCustomVertexFunction;\n            },\n            set: function (val) {\n                this._useCustomVertexFunction = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"isAlwaysVisible\", {\n            get: function () {\n                return this._isAlwaysVisible;\n            },\n            set: function (val) {\n                this.mesh.alwaysSelectAsActiveMesh = val;\n                this._isAlwaysVisible = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicTerrain.prototype, \"precomputeNormalsFromMap\", {\n            get: function () {\n                return this._precomputeNormalsFromMap;\n            },\n            set: function (val) {\n                this._precomputeNormalsFromMap = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        DynamicTerrain.prototype.updateVertex = function (vertex, i, j) {\n            return;\n        };\n        DynamicTerrain.prototype.updateCameraLOD = function (terrainCamera) {\n            var camLOD = 0;\n            return camLOD;\n        };\n        DynamicTerrain.prototype.beforeUpdate = function (refreshEveryFrame) {\n            return;\n        };\n        DynamicTerrain.prototype.afterUpdate = function (refreshEveryFrame) {\n            return;\n        };\n        DynamicTerrain._vertex = {\n            position: BABYLON.Vector3.Zero(),\n            uvs: BABYLON.Vector2.Zero(),\n            color: new BABYLON.Color4(1.0, 1.0, 1.0, 1.0),\n            lodX: 1 | 0,\n            lodZ: 1 | 0,\n            worldPosition: BABYLON.Vector3.Zero(),\n            mapIndex: 0 | 0\n        };\n        DynamicTerrain._v1 = BABYLON.Vector3.Zero();\n        DynamicTerrain._v2 = BABYLON.Vector3.Zero();\n        DynamicTerrain._v3 = BABYLON.Vector3.Zero();\n        DynamicTerrain._v4 = BABYLON.Vector3.Zero();\n        DynamicTerrain._vAvB = BABYLON.Vector3.Zero();\n        DynamicTerrain._vAvC = BABYLON.Vector3.Zero();\n        DynamicTerrain._norm = BABYLON.Vector3.Zero();\n        DynamicTerrain._bbMin = BABYLON.Vector3.Zero();\n        DynamicTerrain._bbMax = BABYLON.Vector3.Zero();\n        return DynamicTerrain;\n    }());\n    BABYLON.DynamicTerrain = DynamicTerrain;\n})(BABYLON || (BABYLON = {}));\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ })

/******/ });