declare module BABYLON {
    class DynamicTerrain {
        name: string;
        private _terrainSub;
        private _mapData;
        private _terrainIdx;
        private _mapSubX;
        private _mapSubZ;
        private _mapUVs;
        private _mapColors;
        private _mapNormals;
        private _SPmapData;
        private _SPcolorData;
        private _SPuvData;
        private _sps;
        private _spsTypeStartIndexes;
        private _nbAvailablePerType;
        private _spsNbPerType;
        private _particleDataStride;
        private _particleColorStride;
        private _particleUVStride;
        private _scene;
        private _subToleranceX;
        private _subToleranceZ;
        private _LODLimits;
        private _initialLOD;
        private _LODValue;
        private _cameraLODCorrection;
        private _LODPositiveX;
        private _LODNegativeX;
        private _LODPositiveZ;
        private _LODNegativeZ;
        private _terrainCamera;
        private _inverted;
        shiftFromCamera: {
            x: number;
            z: number;
        };
        private _indices;
        private _positions;
        private _normals;
        private _colors;
        private _uvs;
        private _deltaSubX;
        private _deltaSubZ;
        private _refreshEveryFrame;
        private _useCustomVertexFunction;
        private _computeNormals;
        private _datamap;
        private _uvmap;
        private _colormap;
        private _mapSPData;
        private _colorSPData;
        private _uvSPData;
        private _mapQuads;
        private static _vertex;
        private _averageSubSizeX;
        private _averageSubSizeZ;
        private _terrainSizeX;
        private _terrainSizeZ;
        private _terrainHalfSizeX;
        private _terrainHalfSizeZ;
        private _centerWorld;
        private _centerLocal;
        private _mapSizeX;
        private _mapSizeZ;
        private _terrain;
        private _isAlwaysVisible;
        private _precomputeNormalsFromMap;
        private static _v1;
        private static _v2;
        private static _v3;
        private static _v4;
        private static _vAvB;
        private static _vAvC;
        private static _norm;
        private static _bbMin;
        private static _bbMax;
        constructor(name: string, options: {
            terrainSub?: number;
            mapData?: number[] | Float32Array;
            mapSubX?: number;
            mapSubZ?: number;
            mapUVs?: number[] | Float32Array;
            mapColors?: number[] | Float32Array;
            mapNormals?: number[] | Float32Array;
            invertSide?: boolean;
            camera?: Camera;
            SPmapData?: number[][] | Float32Array[];
            sps?: SolidParticleSystem;
            SPcolorData?: number[][] | Float32Array[];
            SPuvData?: number[][] | Float32Array[];
        }, scene: Scene);
        update(force: boolean): DynamicTerrain;
        private _updateTerrain;
        private _mod;
        updateTerrainSize(): DynamicTerrain;
        getHeightFromMap(x: number, z: number, options?: {
            normal: Vector3;
        }): number;
        static GetHeightFromMap(x: number, z: number, mapData: number[] | Float32Array, mapSubX: number, mapSubZ: number, options?: {
            normal: Vector3;
        }, inverted?: boolean): number;
        private static _GetHeightFromMap;
        static ComputeNormalsFromMapToRef(mapData: number[] | Float32Array, mapSubX: number, mapSubZ: any, normals: number[] | Float32Array, inverted: boolean): void;
        computeNormalsFromMap(): DynamicTerrain;
        contains(x: number, z: number): boolean;
        static CreateMapFromHeightMap(heightmapURL: string, options: {
            width: number;
            height: number;
            subX: number;
            subZ: number;
            minHeight: number;
            maxHeight: number;
            offsetX: number;
            offsetZ: number;
            onReady?: (map: number[] | Float32Array, subX: number, subZ: number) => void;
            colorFilter?: Color3;
        }, scene: Scene): Float32Array;
        static CreateMapFromHeightMapToRef(heightmapURL: string, options: {
            width: number;
            height: number;
            subX: number;
            subZ: number;
            minHeight: number;
            maxHeight: number;
            offsetX: number;
            offsetZ: number;
            onReady?: (map: number[] | Float32Array, subX: number, subZ: number) => void;
            colorFilter?: Color3;
        }, data: number[] | Float32Array, scene: Scene): void;
        static CreateUVMapToRef(subX: number, subZ: number, mapUVs: number[] | Float32Array): void;
        static CreateUVMap(subX: number, subZ: number): Float32Array;
        createUVMap(): DynamicTerrain;
        refreshEveryFrame: boolean;
        readonly mesh: Mesh;
        camera: Camera;
        subToleranceX: number;
        subToleranceZ: number;
        initialLOD: number;
        readonly LODValue: number;
        cameraLODCorrection: number;
        LODPositiveX: boolean;
        LODNegativeX: boolean;
        LODPositiveZ: boolean;
        LODNegativeZ: boolean;
        readonly averageSubSizeX: number;
        readonly averageSubSizeZ: number;
        readonly terrainSizeX: number;
        readonly terrainHalfSizeX: number;
        readonly terrainSizeZ: number;
        readonly terrainHalfSizeZ: number;
        readonly centerLocal: Vector3;
        readonly centerWorld: Vector3;
        LODLimits: number[];
        mapData: Float32Array | number[];
        mapSubX: number;
        mapSubZ: number;
        mapColors: Float32Array | number[];
        mapUVs: Float32Array | number[];
        mapNormals: Float32Array | number[];
        computeNormals: boolean;
        useCustomVertexFunction: boolean;
        isAlwaysVisible: boolean;
        precomputeNormalsFromMap: boolean;
        updateVertex(vertex: any, i: any, j: any): void;
        updateCameraLOD(terrainCamera: Camera): number;
        beforeUpdate(refreshEveryFrame: boolean): void;
        afterUpdate(refreshEveryFrame: boolean): void;
    }
}
